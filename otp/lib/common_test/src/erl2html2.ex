defmodule :m_erl2html2 do
  use Bitwise
  def convert([], _Dest, _InclPath) do
    :ok
  end

  def convert(file, dest, inclPath) do
    encoding = encoding(file)
    header = ['<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<!-- autogenerated by \'', :erlang.atom_to_list(:erl2html2), '\'. -->\n<html>\n<head>\n<meta http-equiv="Content-Type" content="text/html;charset=',
                                                       html_encoding(encoding),
                                                           '"/></meta>\n<title>', to_raw_list(file,
                                                                            encoding),
                                                                  '</title>\n</head>\n\n<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">\n']
    convert(file, dest, inclPath, header)
  end

  def convert(file, dest, inclPath, header) do
    case (parse_file(file, inclPath)) do
      {:ok, functions} ->
        case (:file.open(file, [:raw, {:read_ahead, 10000}])) do
          {:ok, sFd} ->
            case (:file.open(dest, [:write, :raw])) do
              {:ok, dFd} ->
                :ok = :file.write(dFd, [header, '<pre>\n'])
                _Lines = build_html(sFd, dFd, encoding(file), functions)
                :ok = :file.write(dFd, ['</pre>\n', footer(), '</body>\n</html>\n'])
                :ok = :file.close(sFd)
                :ok = :file.close(dFd)
                :ok
              error ->
                error
            end
          error ->
            error
        end
      error ->
        error
    end
  end

  defp parse_file(file, inclPath) do
    case (:epp.open(file, inclPath, [])) do
      {:ok, epp} ->
        try do
          parse_preprocessed_file(epp, file, false)
        catch
          _, {:error, _Reason, true} ->
            parse_non_preprocessed_file(file)
          _, {:error, _Reason, false} ->
            {:ok, []}
        else
          forms ->
            :epp.close(epp)
            {:ok, forms}
        end
      error = {:error, _} ->
        error
    end
  end

  defp parse_preprocessed_file(epp, file, inCorrectFile) do
    case (:epp.parse_erl_form(epp)) do
      {:ok, form} ->
        case (form) do
          {:attribute, _, :file, {^file, _}} ->
            parse_preprocessed_file(epp, file, true)
          {:attribute, _, :file, {_OtherFile, _}} ->
            parse_preprocessed_file(epp, file, false)
          {:function, l, f, a, cs} when inCorrectFile ->
            {cLs, lastCL} = find_clause_lines(cs, [])
            [{:erlang.atom_to_list(f), a, get_line(l), lastCL} |
                 tl(cLs)] ++ parse_preprocessed_file(epp, file, true)
          _ ->
            parse_preprocessed_file(epp, file, inCorrectFile)
        end
      {:error,
         reason = {_L, :epp, {:undefined, _Macro, :none}}} ->
        throw({:error, reason, inCorrectFile})
      {:error, _Reason} ->
        parse_preprocessed_file(epp, file, inCorrectFile)
      {:warning, _} ->
        parse_preprocessed_file(epp, file, inCorrectFile)
      {:eof, _Location} ->
        []
    end
  end

  defp parse_non_preprocessed_file(file) do
    case (:file.open(file, [])) do
      {:ok, epp} ->
        forms = parse_non_preprocessed_file(epp, file, 1)
        :ok = :file.close(epp)
        {:ok, forms}
      error = {:error, _E} ->
        error
    end
  end

  defp parse_non_preprocessed_file(epp, file, location) do
    case (:epp_dodger.parse_form(epp, location)) do
      {:ok, tree, location1} ->
        try do
          :erl_syntax.revert(tree)
        catch
          _, _ ->
            parse_non_preprocessed_file(epp, file, location1)
        else
          {:function, l, f, a, cs} ->
            {cLs, lastCL} = find_clause_lines(cs, [])
            [{:erlang.atom_to_list(f), a, get_line(l), lastCL} |
                 tl(cLs)] ++ parse_non_preprocessed_file(epp, file,
                                                           location1)
          _ ->
            parse_non_preprocessed_file(epp, file, location1)
        end
      {:error, _E, location1} ->
        parse_non_preprocessed_file(epp, file, location1)
      {:eof, _Location} ->
        []
    end
  end

  defp get_line(anno) do
    :erl_anno.line(anno)
  end

  defp find_clause_lines([{:clause, cL, _Params, _Op, exprs}], cLs) do
    case (classify_exprs(exprs)) do
      {:anno, anno} ->
        {:lists.reverse([{:clause, get_line(cL)} | cLs]),
           get_line(anno)}
      {:tree, exprs1} ->
        find_clause_lines([{:clause, cL, :undefined, :undefined,
                              exprs1}],
                            cLs)
      :unknown ->
        {:lists.reverse([{:clause, get_line(cL)} | cLs]),
           get_line(cL)}
    end
  end

  defp find_clause_lines([{:clause, cL, _Params, _Op, _Exprs} | cs],
            cLs) do
    find_clause_lines(cs, [{:clause, get_line(cL)} | cLs])
  end

  defp classify_exprs(exprs) do
    case (:erlang.tuple_to_list(:lists.last(exprs))) do
      [:macro, {_var, anno, _MACRO} | _] ->
        {:anno, anno}
      [t, exprAnno | exprs1] ->
        case (:erl_anno.is_anno(exprAnno)) do
          true ->
            {:anno, exprAnno}
          false when t === :tree ->
            {:tree, exprs1}
          false ->
            :unknown
        end
    end
  end

  defp build_html(sFd, dFd, encoding, funcsAndCs) do
    build_html(sFd, dFd, encoding, :file.read_line(sFd), 1,
                 funcsAndCs, false, :undefined)
  end

  defp build_html(sFd, dFd, enc, {:ok, str}, lastL, funcsAndCs,
            _IsFuncDef, {f, lastL}) do
    lastLineLink = :test_server_ctrl.uri_encode(f ++ '-last_expr',
                                                  :utf8)
    :ok = :file.write(dFd,
                        ['<a name="', to_raw_list(lastLineLink, enc), '"/>'])
    build_html(sFd, dFd, enc, {:ok, str}, lastL, funcsAndCs,
                 true, :undefined)
  end

  defp build_html(sFd, dFd, enc, {:ok, str}, l0,
            [{f, a, l0, lastL} | funcsAndCs], _IsFuncDef,
            _FAndLastL) do
    fALink = :test_server_ctrl.uri_encode(f ++ '-' ++ :erlang.integer_to_list(a),
                                            :utf8)
    :ok = :file.write(dFd, ['<a name="', to_raw_list(fALink, enc), '"/>'])
    build_html(sFd, dFd, enc, {:ok, str}, l0, funcsAndCs,
                 true, {f, lastL})
  end

  defp build_html(sFd, dFd, enc, {:ok, str}, l,
            [{:clause, l} | funcsAndCs], _IsFuncDef, fAndLastL) do
    build_html(sFd, dFd, enc, {:ok, str}, l, funcsAndCs,
                 true, fAndLastL)
  end

  defp build_html(sFd, dFd, enc, {:ok, str}, l, funcsAndCs,
            isFuncDef, fAndLastL) do
    lStr = line_number(l)
    str1 = line(str, isFuncDef)
    :ok = :file.write(dFd, [lStr, str1])
    build_html(sFd, dFd, enc, :file.read_line(sFd), l + 1,
                 funcsAndCs, false, fAndLastL)
  end

  defp build_html(_SFd, _DFd, _Enc, :eof, l, _FuncsAndCs,
            _IsFuncDef, _FAndLastL) do
    l
  end

  defp line_number(l) do
    lStr = :erlang.integer_to_list(l)
    pred = (case (length(lStr)) do
              length when length < 5 ->
                :lists.duplicate(5 - length, ?\s)
              _ ->
                []
            end)
    ['<a name="', lStr, '"/>', pred, lStr, ': ']
  end

  defp line(str, isFuncDef) do
    str1 = htmlize(str)
    possibly_enhance(str1, isFuncDef)
  end

  defp htmlize([?< | str]) do
    [?&, ?l, ?t, ?; | htmlize(str)]
  end

  defp htmlize([?> | str]) do
    [?&, ?g, ?t, ?; | htmlize(str)]
  end

  defp htmlize([?& | str]) do
    [?&, ?a, ?m, ?p, ?; | htmlize(str)]
  end

  defp htmlize([?" | str]) do
    [?&, ?q, ?u, ?o, ?t, ?; | htmlize(str)]
  end

  defp htmlize([ch | str]) do
    [ch | htmlize(str)]
  end

  defp htmlize([]) do
    []
  end

  defp possibly_enhance(str, true) do
    case (:lists.splitwith(fn ?( ->
                                false
                              _ ->
                                true
                           end,
                             str)) do
      {_, []} ->
        str
      {f, a} ->
        ['<b>', f, '</b>', a]
    end
  end

  defp possibly_enhance([?% | _] = str, _) do
    ['<i>', str -- '\n', '</i>', '\n']
  end

  defp possibly_enhance([?- | _] = str, _) do
    possibly_enhance(str, true)
  end

  defp possibly_enhance(str, false) do
    str
  end

  defp footer() do
    ''
  end

  defp encoding(file) do
    case (:epp.read_encoding(file)) do
      :none ->
        :epp.default_encoding()
      e ->
        e
    end
  end

  defp html_encoding(:latin1) do
    'iso-8859-1'
  end

  defp html_encoding(:utf8) do
    'utf-8'
  end

  defp to_raw_list(x, :latin1) when is_list(x) do
    x
  end

  defp to_raw_list(x, :utf8) when is_list(x) do
    :erlang.binary_to_list(:unicode.characters_to_binary(x))
  end

end